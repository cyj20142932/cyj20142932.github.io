{"posts":[{"title":"Vue源码探析——tokens+数据转换为dom字符串！","content":"tokens+数据转换为dom字符串！ 简单地例子 模板 const templateStr = &quot;&lt;h1&gt;我买了一个{{thing}}，好{{mood}}啊！&lt;h1&gt;&quot;; 数据 const data = { thing: &quot;华为手机&quot;, mood: '开心' } 生成dom字符串 /** * 数据结合tokens生成dom * @param {*} tokens * @param {*} data */ export default function renderTemplate(tokens, data) { // console.log(tokens); // console.log(data); let resultStr = &quot;&quot;; //每一个token都是一个二维数组 for (const token of tokens) { if (token[0] == &quot;text&quot;) { resultStr += token[1]; } else if (token[0] == &quot;name&quot;) { resultStr += data[token[1]]; } else { } } return resultStr; } 这一部分是比较简单地，因为仅仅只有一个大括号，并且数据并没有嵌套（也就是 {a:{b:{c:100}}} 即a.b.c），而且还不包括数组循环嵌套结构，也就是没有#这样的标记，我们从最简单的一步步来，tokens变为dom的最难点就是这种嵌套结构的！ 接下来的嵌套结构思路 由于#标记的那一项也是一个tokens，和最外层是类似的，此处的编程思维需要用到递归，一层一层处理。在正式些递归之前，我们需要了解的是，到目前为止我们还没遇到对象嵌套的情况，因此我们需要对此进行特殊处理！ 模板和数据 const templateStr = ` {{#arr}} &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;{{name}}的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：{{name}}&lt;/p&gt; &lt;p&gt;年龄：{{age}}&lt;/p&gt; &lt;p&gt;性别：{{sex}}&lt;/p&gt; &lt;/div&gt; &lt;ol&gt; {{#hobbies}} &lt;li&gt;{{.}}&lt;/li&gt; {{/hobbies}} &lt;/ol&gt; &lt;/li&gt; {{/arr}}`; const data = { arr: [ { name: &quot;小明&quot;, age: 20, sex: &quot;男&quot;, hobbies: [&quot;羽毛球&quot;, &quot;乒乓球&quot;] }, { name: &quot;小红&quot;, age: 21, sex: &quot;女&quot;, hobbies: [&quot;羽毛球&quot;, &quot;乒乓球&quot;] }, { name: &quot;小张&quot;, age: 23, sex: &quot;男&quot;, hobbies: [&quot;羽毛球&quot;, &quot;乒乓球&quot;] }, ] } //函数的功能，功能是取的嵌套结构的数据值，也就是 {a:{b:{c:100}}} 即a.b.c export default function lookup(dataObj, keyName) { //不需要判断. let keys = keyName.split(&quot;,&quot;); let value = dataObj; for (const key of keys) { value = value[key]; } return value; } 那么我们上一部分代码可以改造一下 export default function renderTemplate(tokens, data) { // console.log(tokens); // console.log(data); let resultStr = &quot;&quot;; //每一个token都是一个二维数组 for (const token of tokens) { if (token[0] == &quot;text&quot;) { resultStr += token[1]; } else if (token[0] == &quot;name&quot;) { resultStr += lookup(data, token[1]); } else if (token[0] == &quot;#&quot;) { // resultStr+= } } return resultStr; } 递归 import renderTemplate from &quot;./renderTemplate.js&quot;; import lookup from &quot;./lookup&quot;; /* * 处理嵌套递归,需要递归调用解析token函数，低估次数取决于数据数组的长度，因为是循环 */ export default function parseArray(token, data) { let resultStr = &quot;&quot;; let arrs = lookup(data, token[1]); for (const value of arrs) { // console.log(value); //数组有可能不是对象数组，如这样的数组 [&quot;羽毛球&quot;,&quot;乒乓球&quot;]，这时候需要改下一lookup函数，因为这个地方是一个.，因此需要将.特殊考虑 resultStr += renderTemplate(token[2], { &quot;.&quot;: value, ...value, }); } return resultStr; } 并且这里我们lookup函数需要改造一下！ //函数的功能，功能是取的嵌套结构的数据值，也就是 {a:{b:{c:100}}} 即a.b.c export default function lookup(dataObj, keyName) { //不能是点本身 if (keyName != &quot;.&quot;) { let keys = keyName.split(&quot;,&quot;); let value = dataObj; for (const key of keys) { value = value[key]; } return value; } return dataObj[keyName]; } import lookup from &quot;./lookup.js&quot;; import parseArray from &quot;./parseArray.js&quot;; /** * 数据结合tokens生成dom * @param {*} tokens * @param {*} data */ export default function renderTemplate(tokens, data) { // console.log(tokens); // console.log(data); let resultStr = &quot;&quot;; //每一个token都是一个二维数组 for (const token of tokens) { if (token[0] == &quot;text&quot;) { resultStr += token[1]; } else if (token[0] == &quot;name&quot;) { resultStr += lookup(data, token[1]); } else if (token[0] == &quot;#&quot;) { resultStr += parseArray(token, data); } } return resultStr; } 至此，我们的模板引擎就编写完成了，是的就完成了！不过这不是一个完成模板引擎，仅仅是为了展示mustache的核心算法以及核心的一些思路！ ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-tokensshu-ju-zhuan-huan-wei-dom-zi-fu-chuan/"},{"title":"Vue源码探析——模板字符串转tokens算法！","content":"模板字符串转tokens，需要依据Scanner来对tokens进行一个收集！ 这里我们直接给出算法 export default function parseTemplateToTokens(templateStr) { const tokens = []; var scanner = new Scanner(templateStr); let words = &quot;&quot;; while (!scanner.isEos()) { words = scanner.scanUntil(&quot;{{&quot;); words != &quot;&quot; &amp;&amp; tokens.push([&quot;text&quot;, words]); scanner.scan(&quot;{{&quot;); words = scanner.scanUntil(&quot;}}&quot;); if (words != &quot;&quot;) { if (words[0] == &quot;#&quot;) { tokens.push([&quot;#&quot;, words.substring(1)]); } else if (words[0] == &quot;/&quot;) { tokens.push([&quot;/&quot;, words.substring(1)]); } else { tokens.push([&quot;name&quot;, words]); } } scanner.scan(&quot;}}&quot;); } return nestTokens(tokens); } export default function nestTokens(tokens) { //结果 const nestTokens = []; //栈结构 const sections = []; //当前正在收集的tokens,默认收集到初始的结果数组，引用类型值， let collector = nestTokens; for (const token of tokens) { switch (token[0]) { case &quot;#&quot;: //收集器放入token collector.push(token); //入栈 sections.push(token); //此时收集器需要收集下标为2 的项的tokens collector = token[2] = []; break; case &quot;/&quot;: //出栈,返回刚刚弹出的项 sections.pop(); if (sections.length &gt; 0) { collector = sections[sections.length - 1][2]; } else { collector = nestTokens; } break; default: collector.push(token); break; } } 主要就是运用栈的结构以及js引用类型来解决嵌套问题，此处的算法需要好好研究！ ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-mo-ban-zi-fu-chuan-zhuan-tokens-suan-fa/"},{"title":"Vue源码探析——mustache之扫描器Scanner的主要功能原理！","content":"在mustache的源码中，有一个Scanner类，主要负责字符串的扫描并记录操作，是底层模板字符串转换为tokens的一个重要步骤！ 示例模板字符串 &lt;h1&gt;我买了一个{{thing}}，好{{mood}}啊！&lt;/h1&gt; Scanner主要是两个功能，扫描模板字符串直到遇见指定的字符（比如我们的{{或者}}），然后当遇到指定字符的时候则扫描的指针需要跳过指定字符的长度 主要实现 1、index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./xuni/boundle.js&quot;&gt;&lt;/script&gt; &lt;script&gt; let el = document.getElementById('content'); const templateStr = &quot;&lt;h1&gt;我买了一个{{thing}}，好{{mood}}啊！&lt;h1&gt;&quot;; const data = { thing: &quot;华为手机&quot;, mood: &quot;开心&quot; } const result = moonEngine.render(templateStr, data); el.innerHTML = result; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2、Scanner.js /** * 扫描器类 */ export class Scanner { constructor(templateStr) { this.templateStr = templateStr; //当前指针位置 this.pos = 0; //尾巴字符串，初始化的时候等于模板字符串 this.tail = this.templateStr; } //路过某些内容，没有返回值 scan(tag) { if (this.tail.indexOf(tag) == 0) { //tag有多长，如：‘{{’长度是2 this.pos += tag.length; //尾巴也变了 this.tail = this.templateStr.substring(this.pos); } } //让指针进行扫描，知道遇到指定内容结束，并且能返回结束之前路过的字符 scanUntil(stopTag) { //记录开始执行此方法是指针位置 const pos_backup = this.pos; //当尾巴开头不是stopTag的时候说明还没有扫描到 while ( this.tail.indexOf(stopTag) != 0 &amp;&amp; this.pos &lt; this.templateStr.length ) { this.pos++; //改变尾巴 this.tail = this.templateStr.substring(this.pos); } return this.templateStr.substring(pos_backup, this.pos); } } 3、index.js import { Scanner } from &quot;./Scanner.js&quot;; window.moonEngine = { render(templateStr, data) { var scanner = new Scanner(templateStr); let words = &quot;&quot;; while (scanner.pos != templateStr.length) { words = scanner.scanUntil(&quot;{{&quot;); scanner.scan(&quot;{{&quot;); console.log(scanner.pos); console.log(words); words = scanner.scanUntil(&quot;}}&quot;); scanner.scan(&quot;}}&quot;); console.log(scanner.pos); console.log(words); } }, }; 4、启动项目，yarn dev 到浏览器查看最终效果 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-mustache-zhi-sao-miao-qi-scanner-de-zhu-yao-zuo-yong/"},{"title":"Vue源码探析——前端工程化，搭建mastache开发环境！","content":"在正式的手动编写mastache源码之前，我们先需要将我们的开发环境搭建起来，在目前的大环境下，前端工程化是很有必要的，特别是当es6出现后，则工程化成了必然，我们使用和课程中一致环境，使用webpack来完成我们项目的搭建！ 1、首先我们新建一个文件夹 既然我们是手写那么我们就自己取一个名字，我这里使用MoonEngine，作为我们项目的名称 接下来我们使用npm进行初始化，并且安装相关的依赖包，这里我们使用VSCode作为我们的代码编写开发工具，我们直接用VSCode打开文件夹，以及执行以下命令 npm init 一路回车 然后安装webpack相关依赖，这我们自己指定相关版本 npm i -D webpack@4 webpack-dev-server@3 webpack-cli@3 安装过程中，可以先手动创建一个webpack的配置文件webpack.config const path = require(&quot;path&quot;); module.exports = { //模式，开发 mode: &quot;development&quot;, //入口文件 entry: &quot;./src/index.js&quot;, //出口文件，打包的位置 output: { filename: &quot;boundle.js&quot;, }, //webpack-dev-server配置 devServer: { contentBase: path.join(__dirname, &quot;public&quot;), compress: false, port: 8080, publicPath: &quot;/xuni/&quot;, }, }; 然后改一些配置文件中的script节点，并新建好相关文件，如下图 其中index.html的内容如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Vue!&lt;/h1&gt; &lt;script src=&quot;./xuni/boundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这样我们的基础环境就搭建完成了，然后在命令行运行 npm run dev 打开浏览器http://localhost:8080 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-qian-duan-gong-cheng-hua-da-jian-mastache-kai-fa-huan-jing/"},{"title":"Vue源码探析——mustache库的实现机理！","content":"mustache作为模板引擎的开山鼻祖，我们有必要从机理上就弄懂它，毕竟诸如Vue等库也都是有借鉴它的，因此，弄会了mustache之后再去理解vue则要简单的多！ mustache实现机理简易图解 1、什么是tokens？ tokens实际上就是模板字符串的JS表示，由一个JS的嵌套数组组成，毫不夸张，它是“抽象语法树”、“虚拟节点”等等的开山鼻祖！ 比如以下模板字符串 &lt;h1&gt;我买了一个{{thing}},好{{mood}}啊&lt;/h1&gt; 这一段模板中字符串由tokens表示则是以下数组形式 [ [&quot;text&quot;, &quot;&lt;h1&gt;我买了一个&quot;], [&quot;name&quot;, &quot;thing&quot;], [&quot;text&quot;, &quot;,好&quot;], [&quot;name&quot;, &quot;mood&quot;], [&quot;text&quot;, &quot;啊&lt;/h1&gt;&quot;] ] 纯文字则为text，不区分是否是标签，对于模板引擎都是字符串。大括号内部的就是name，每一个token都是一个数组 //数据 data = { thing: &quot;华为手机&quot;, mood: &quot;开心&quot; } 将模板字符串编译成tokens,tokens结合数据进行解析最终生成dom字符串 2、循环出现时的tokens结构 比如下面这种 &lt;div&gt; &lt;ul&gt; {{#arr}} &lt;li&gt;{{.}}&lt;/li&gt; {{/arr}} &lt;/ul&gt; &lt;/div&gt; 则对应的tokens则是一个嵌套的tokens [ [&quot;text&quot;, &quot;&lt;div&gt;&lt;ul&gt;&quot;], [&quot;#&quot;, &quot;arr&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;&quot;], [&quot;name&quot;, &quot;.&quot;], [&quot;text&quot;, &quot;&lt;/li&gt;&quot;] ]], [&quot;text&quot;, &quot;&lt;/ul&gt;&lt;div&gt;&quot;] ] 更加复杂的结构，双重循环的结构 &lt;div&gt; &lt;ol&gt; {{#students}} &lt;li&gt; 学生{{name}}的爱好是 &lt;ol&gt; {{#hobbies}} &lt;li&gt; {{.}} &lt;/li&gt; {{/hobbies}} &lt;/ol&gt; &lt;/li&gt; {{/students}} &lt;/ol&gt; &lt;/div&gt; 那么编译出来的tokens则是如下这种结构 [ [&quot;text&quot;, &quot;&lt;div&gt;&lt;ol&gt;&quot;], [&quot;#&quot;, &quot;students&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;学生&quot;], [&quot;name&quot;, &quot;name&quot;], [&quot;text&quot;, &quot;的爱好是&lt;ol&gt;&quot;] [&quot;#&quot;, &quot;hobbies&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;&quot;] [&quot;name&quot;, &quot;.&quot;] [&quot;text&quot;, &quot;&lt;/li&gt;&quot;] ]] [&quot;text&quot;, &quot;&lt;/ol&gt;&lt;/li&gt;&quot;] ]], [&quot;text&quot;, &quot;&lt;/ol&gt;&lt;/div&gt;&quot;], ] 3、mustache库的底层核心 将模板字符串编译为tokens 将tokens结合数据，解析为dom字符串 后续文章将开始为手写mastache源码做准备 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-mustache-ku-de-shi-xian-ji-li/"},{"title":"Vue源码探析——正则表达式方式实现简易模板引擎！","content":"为了更好地理解Vue等其它类似库的实现原理，那么我们则需要弄懂模板引擎的底层机理，必须从最基础的模板引擎开始，才能更加透彻的弄懂Vue! 在正式的探究mustache的实现机理之前，我们需要先使用正则表达式的方式来模拟一个简易的模板引擎，或者说这不能成为引擎，只能说是一种字符串替换能力，用来实现简单地数据到视图的转换！ 正则表达式实现一个简单地字符串处理能力 这里就引用课程中的实例了，也比较简单，容易理解 //正则方式实现字符串内容的替换 const templateStr = '&lt;h1&gt;我买了一个{{thing}}，好{{mood}}&lt;/h1&gt;'; const data = { thing: &quot;华为手机&quot;, mood: &quot;高兴&quot; } const newStr = templateStr.replace(/\\{\\{(\\w+)\\}\\}/g, function (finedStr, str) { console.log(arguments); return data[str] }) console.log(newStr); 一下就是效果，通过replace的方式function回调的方式，将某些内容进行替换和提取， 这种方式确实可以实现一些简单地数据视图转换，但是能解决的需求都无法太复杂，也就是说，这顶多只能当做一个功能函数，而想要以此来实现更加复杂的需求，显然显得有些不够看了。 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-mustache-mo-ban-yin-qing-de-shi-xian-ji-li/"},{"title":"Vue源码探析——数据如何变视图？","content":"Vue源码探析——数据如何变视图？ 历史上开发网页页面的方式有很多，从最开始的纯DOM操作将数据动态变为视图，到有段时期的数组join方式（笔者其实没见过）间接转换，到es6的模板字符串，再到后来的模板引擎渲染页面，不同的时期使用不同的方式，到目前为止，模板引擎的方式显然更加优雅！下面我们以一组结构为例，看看使用这几种方式如何实现同一个效果！ （笔记课程来源）[https://www.bilibili.com/video/BV1EV411h79m] 最终结果页面的html代码 &lt;ul id=&quot;list&quot;&gt; &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;小明的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20&lt;/p&gt; &lt;p&gt;性别：男&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;小红的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：小红&lt;/p&gt; &lt;p&gt;年龄：21&lt;/p&gt; &lt;p&gt;性别：女&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;小张的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：小张&lt;/p&gt; &lt;p&gt;年龄：23&lt;/p&gt; &lt;p&gt;性别：男&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; 公用测试数据 const dataItems = [ { name: &quot;小明&quot;, age: 20, sex: &quot;男&quot;, }, { name: &quot;小红&quot;, age: 21, sex: &quot;女&quot;, }, { name: &quot;小张&quot;, age: 23, sex: &quot;男&quot;, }, ]; 下面我们就以这四种方式来实现同样的需求 1、纯DOM方式实现 const uEl = document.getElementById(&quot;list&quot;); for (const item of dataItems) { //创建一个li标签 let liEl = document.createElement(&quot;li&quot;); //liEl下面有两个div，因此需要创建两个div标签 let divHd = document.createElement(&quot;div&quot;); divHd.innerText = item.name + &quot;的基本信息&quot;; //divHd需要将divHd append到li上 liEl.append(divHd); let divBd = document.createElement(&quot;div&quot;); //div下还有三个p标签 let p1 = document.createElement(&quot;p&quot;); p1.innerText = &quot;姓名：&quot; + item.name; divBd.append(p1); let p2 = document.createElement(&quot;p&quot;); p2.innerText = &quot;年龄：&quot; + item.age; divBd.append(p2); let p3 = document.createElement(&quot;p&quot;); p3.innerText = &quot;性别：&quot; + item.sex; divBd.append(p3); //需要将divBd append到li上 liEl.append(divBd); //最后liEl需要append到uEl节点上，完成上树 uEl.append(liEl); } 以上写法不是唯一，只是为了展示纯DOM的方式，可以看到，这种方式是非常麻烦的，通过纯粹的dom方式是最底层的方式，但是在现在来看，这种方式确实过于繁琐 2、数组Join法（确实没听说过也没用过） 数组join法据说是为了解决无法换行字符串（es6之前没有模板字符串）而被人们想出来的一种另类的方法，说白了实际上就是为了让代码看上去更加有结构，据说是曾经前端必回知识，下面我们看看代码： for (const item of dataItems) { const str = [ '&lt;li&gt;', ' &lt;div class=&quot;hd&quot;&gt;' + item.name + '的基本信息&lt;/div&gt;', ' &lt;div class=&quot;bd&quot;&gt;', ' &lt;p&gt;姓名：' + item.name + '&lt;/p&gt;', ' &lt;p&gt;年龄：' + item.age + '&lt;/p&gt;', ' &lt;p&gt;性别：' + item.sex + '&lt;/p&gt;', ' &lt;/div&gt;', '&lt;/li&gt;', ].join('') uEl.innerHTML += str; } 3、es6模板字符串方式 来到es6之后字符串就变得简单了，也就是模板字符串（反引号方法）可以换行来写,就算是现在，在很多场合也是很有用的，并且很多时候用起来非常的方便。 const uEl = document.getElementById(&quot;list&quot;); for (const item of dataItems) { let str = ` &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;${item.name}的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：${item.name}&lt;/p&gt; &lt;p&gt;年龄：${item.age}&lt;/p&gt; &lt;p&gt;性别：${item.sex}&lt;/p&gt; &lt;/div&gt; &lt;/li&gt;` uEl.innerHTML += str; } 4、模板引擎的方式 模板引擎，我们依据课程，采用的是mustache模板引擎的方式来实现同样的效果,mustache是最早的html模板引擎，它的出现是极具创造性的，vue等库的底层实现也是依赖模板引擎的，当然Vue有着自己的一套！ mustache开源地址：[https://github.com/janl/mustache.js/] &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.min.js&quot;&gt; &lt;/script&gt; &lt;script id=&quot;template&quot; type=&quot;x-tmpl-mustache&quot;&gt; {{#arr}} &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;{{ name }}的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：{{ name }}&lt;/p&gt; &lt;p&gt;年龄：{{ age }}&lt;/p&gt; &lt;p&gt;性别：{{ sex }}&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; {{/arr}} &lt;/script&gt; &lt;script&gt; var template = document.getElementById('template').innerHTML; var rendered = Mustache.render(template, { arr: dataItems }); document.getElementById('list').innerHTML = rendered; &lt;/script&gt; 从代码可以看出，虽然代码量不是最少的，但是其思想确实最具创造性的，通过模板的方式，结构更加清晰，让数据更加容易的生成视图。这里只是展示一个小小的例子，mustache还可以实现更加复杂的需求，比如数组的嵌套，条件判断等等 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-shu-ju-ru-he-bian-shi-tu/"},{"title":"CSS实用片段","content":"CSS常用的代码片段 这是CSS浏览器重置的基本和常见的CSS代码段 html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } html { height: 101%; } body { font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; } article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } strong { font-weight: bold; } table { border-collapse: collapse; border-spacing: 0; } img { border: 0; max-width: 100%; } p { font-size: 1.2em; line-height: 1.0em; color: #333; } 跨浏览器透明度设置 .transparent { -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;;/* IE 8 */ filter: alpha(opacity=50); /* IE 5-7 */ -moz-opacity: 0.5;/* Netscape */ -khtml-opacity: 0.5; /* Safari 1.x */ opacity: 0.5; /* Good browsers */ } 常规媒体查询 /* Smartphones (portrait and landscape) ----------- */ @media only screen and (min-device-width : 320px) and (max-device-width : 480px) { } /* Smartphones (landscape) ----------- */ @media only screen and (min-width : 321px) { } /* Smartphones (portrait) ----------- */ @media only screen and (max-width : 320px) { } /* iPads (portrait and landscape) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) { } /* iPads (landscape) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) { } /* iPads (portrait) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) { } /* Desktops and laptops ----------- */ @media only screen and (min-width : 1224px) { } /* Large screens ----------- */ @media only screen and (min-width : 1824px) { } /* iPhone 4 ----------- */ @media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) { } 自定义选中文本 ::selection { background: #51a351; } ::-moz-selection { background: #51a351; } ::-webkit-selection { background: #51a351; } 带CSS3的全屏背景 html { background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover; } 强制垂直滚动条 html { height: 101% } 文本首字母大写 p:first-letter { display: block; margin: 4px 0 0 4px; float: left; color: #ff3366; font-size: 5.3em; font-family: Georgia, Times New Roman, serif; } 内外阴影 #mydiv { -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000; } #mydiv { -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); } 语音气泡 .speech-bubble { position: relative; background: #00aabb; border-radius: .4em; } .speech-bubble:after { content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 0; border: 30px solid transparent; border-top-color: #00aabb; border-bottom: 0; border-left: 0; margin-left: -15px; margin-bottom: -30px; } 自定义输入样式 input[type=text], textarea { -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd; } input[type=text]:focus, textarea:focus { box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1); } ","link":"https://cyj20142932.github.io/post/css-shi-yong-pian-duan/"},{"title":"实用JavaScript库合集！","content":"实用的JavaScript库！不断收集中…… 1、优秀的JavaScript 字符串处理库——vocajs Voca库提供了一些有用的函数，可以让字符串操作更舒适：改变大小写、修剪、填充、slugify、拉丁化、sprintf'y、truncate、escape等等。模块化设计允许加载整个库或单个函数以最小化应用程序构建。该库经过充分测试，文档齐全，并得到长期支持。 文档地址：vocajs✍️ Github地址：Github⚙️ 2、浏览器缓存（数据库）操作——localForage.js localForage 是一个 JavaScript 库，通过简单类似 localStorage API 的异步存储来改进你的 Web 应用程序的离线体验。它能存储多种类型的数据，而不仅仅是字符串。 localForage 有一个优雅降级策略，若浏览器不支持 IndexedDB 或 WebSQL，则使用 localStorage。在所有主流浏览器中都可用：Chrome，Firefox，IE 和 Safari（包括 Safari Mobile） localForage 提供回调 API 同时也支持 ES6 Promises API，可以自行选择。 文档地址：localForage.js✍️ Github地址：Github⚙️ 3、用于任意精度十进制和非十进制算法的JavaScript库——bignumber.js 用于任意精度十进制和非十进制算法的JavaScript库 文档地址：bignumber.js✍️ Github地址：Github⚙️ ","link":"https://cyj20142932.github.io/post/shi-yong-javascript-ku-he-ji/"},{"title":"Gridea博客客户端","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://cyj20142932.github.io/post/hello-gridea/"}]}