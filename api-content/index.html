{"posts":[{"title":"实用JavaScript库合集！","content":"实用的JavaScript库！不断收集中…… 1、优秀的JavaScript 字符串处理库！vocajs Voca库提供了一些有用的函数，可以让字符串操作更舒适：改变大小写、修剪、填充、slugify、拉丁化、sprintf'y、truncate、escape等等。模块化设计允许加载整个库或单个函数以最小化应用程序构建。该库经过充分测试，文档齐全，并得到长期支持。 文档地址：vocajs✍️ Github地址：Github⚙️ ","link":"https://cyj20142932.github.io/post/shi-yong-javascript-ku-he-ji/"},{"title":"Vue源码探析——mustache库的实现机理！","content":"mustache作为模板引擎的开山鼻祖，我们有必要从机理上就弄懂它，毕竟诸如Vue等库也都是有借鉴它的，因此，弄会了mustache之后再去理解vue则要简单的多！ mustache实现机理简易图解 1、什么是tokens？ tokens实际上就是模板字符串的JS表示，由一个JS的嵌套数组组成，毫不夸张，它是“抽象语法树”、“虚拟节点”等等的开山鼻祖！ 比如以下模板字符串 &lt;h1&gt;我买了一个{{thing}},好{{mood}}啊&lt;/h1&gt; 这一段模板中字符串由tokens表示则是以下数组形式 [ [&quot;text&quot;, &quot;&lt;h1&gt;我买了一个&quot;], [&quot;name&quot;, &quot;thing&quot;], [&quot;text&quot;, &quot;,好&quot;], [&quot;name&quot;, &quot;mood&quot;], [&quot;text&quot;, &quot;啊&lt;/h1&gt;&quot;] ] 纯文字则为text，不区分是否是标签，对于模板引擎都是字符串。大括号内部的就是name，每一个token都是一个数组 //数据 data = { thing: &quot;华为手机&quot;, mood: &quot;开心&quot; } 将模板字符串编译成tokens,tokens结合数据进行解析最终生成dom字符串 2、循环出现时的tokens结构 比如下面这种 &lt;div&gt; &lt;ul&gt; {{#arr}} &lt;li&gt;{{.}}&lt;/li&gt; {{/arr}} &lt;/ul&gt; &lt;/div&gt; 则对应的tokens则是一个嵌套的tokens [ [&quot;text&quot;, &quot;&lt;div&gt;&lt;ul&gt;&quot;], [&quot;#&quot;, &quot;arr&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;&quot;], [&quot;name&quot;, &quot;.&quot;], [&quot;text&quot;, &quot;&lt;/li&gt;&quot;] ]], [&quot;text&quot;, &quot;&lt;/ul&gt;&lt;div&gt;&quot;] ] 更加复杂的结构，双重循环的结构 &lt;div&gt; &lt;ol&gt; {{#students}} &lt;li&gt; 学生{{name}}的爱好是 &lt;ol&gt; {{#hobbies}} &lt;li&gt; {{.}} &lt;/li&gt; {{/hobbies}} &lt;/ol&gt; &lt;/li&gt; {{/students}} &lt;/ol&gt; &lt;/div&gt; 那么编译出来的tokens则是如下这种结构 [ [&quot;text&quot;, &quot;&lt;div&gt;&lt;ol&gt;&quot;], [&quot;#&quot;, &quot;students&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;学生&quot;], [&quot;name&quot;, &quot;name&quot;], [&quot;text&quot;, &quot;的爱好是&lt;ol&gt;&quot;] [&quot;#&quot;, &quot;hobbies&quot;, [ [&quot;text&quot;, &quot;&lt;li&gt;&quot;] [&quot;name&quot;, &quot;.&quot;] [&quot;text&quot;, &quot;&lt;/li&gt;&quot;] ]] [&quot;text&quot;, &quot;&lt;/ol&gt;&lt;/li&gt;&quot;] ]], [&quot;text&quot;, &quot;&lt;/ol&gt;&lt;/div&gt;&quot;], ] 3、mustache库的底层核心 将模板字符串编译为tokens 将tokens结合数据，解析为dom字符串 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-mustache-ku-de-shi-xian-ji-li/"},{"title":"Vue源码探析——正则表达式方式实现简易模板引擎！","content":"为了更好地理解Vue等其它类似库的实现原理，那么我们则需要弄懂模板引擎的底层机理，必须从最基础的模板引擎开始，才能更加透彻的弄懂Vue! 在正式的探究mustache的实现机理之前，我们需要先使用正则表达式的方式来模拟一个简易的模板引擎，或者说这不能成为引擎，只能说是一种字符串替换能力，用来实现简单地数据到视图的转换！ 正则表达式实现一个简单地字符串处理能力 这里就引用课程中的实例了，也比较简单，容易理解 //正则方式实现字符串内容的替换 const templateStr = '&lt;h1&gt;我买了一个{{thing}}，好{{mood}}&lt;/h1&gt;'; const data = { thing: &quot;华为手机&quot;, mood: &quot;高兴&quot; } const newStr = templateStr.replace(/\\{\\{(\\w+)\\}\\}/g, function (finedStr, str) { console.log(arguments); return data[str] }) console.log(newStr); 一下就是效果，通过replace的方式function回调的方式，将某些内容进行替换和提取， 这种方式确实可以实现一些简单地数据视图转换，但是能解决的需求都无法太复杂，也就是说，这顶多只能当做一个功能函数，而想要以此来实现更加复杂的需求，显然显得有些不够看了。 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-mustache-mo-ban-yin-qing-de-shi-xian-ji-li/"},{"title":"Vue源码探析——数据如何变视图？","content":"Vue源码探析——数据如何变视图？ 历史上开发网页页面的方式有很多，从最开始的纯DOM操作将数据动态变为视图，到有段时期的数组join方式（笔者其实没见过）间接转换，到es6的模板字符串，再到后来的模板引擎渲染页面，不同的时期使用不同的方式，到目前为止，模板引擎的方式显然更加优雅！下面我们以一组结构为例，看看使用这几种方式如何实现同一个效果！ （笔记课程来源）[https://www.bilibili.com/video/BV1EV411h79m] 最终结果页面的html代码 &lt;ul id=&quot;list&quot;&gt; &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;小明的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20&lt;/p&gt; &lt;p&gt;性别：男&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;小红的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：小红&lt;/p&gt; &lt;p&gt;年龄：21&lt;/p&gt; &lt;p&gt;性别：女&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;小张的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：小张&lt;/p&gt; &lt;p&gt;年龄：23&lt;/p&gt; &lt;p&gt;性别：男&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; 公用测试数据 const dataItems = [ { name: &quot;小明&quot;, age: 20, sex: &quot;男&quot;, }, { name: &quot;小红&quot;, age: 21, sex: &quot;女&quot;, }, { name: &quot;小张&quot;, age: 23, sex: &quot;男&quot;, }, ]; 下面我们就以这四种方式来实现同样的需求 1、纯DOM方式实现 const uEl = document.getElementById(&quot;list&quot;); for (const item of dataItems) { //创建一个li标签 let liEl = document.createElement(&quot;li&quot;); //liEl下面有两个div，因此需要创建两个div标签 let divHd = document.createElement(&quot;div&quot;); divHd.innerText = item.name + &quot;的基本信息&quot;; //divHd需要将divHd append到li上 liEl.append(divHd); let divBd = document.createElement(&quot;div&quot;); //div下还有三个p标签 let p1 = document.createElement(&quot;p&quot;); p1.innerText = &quot;姓名：&quot; + item.name; divBd.append(p1); let p2 = document.createElement(&quot;p&quot;); p2.innerText = &quot;年龄：&quot; + item.age; divBd.append(p2); let p3 = document.createElement(&quot;p&quot;); p3.innerText = &quot;性别：&quot; + item.sex; divBd.append(p3); //需要将divBd append到li上 liEl.append(divBd); //最后liEl需要append到uEl节点上，完成上树 uEl.append(liEl); } 以上写法不是唯一，只是为了展示纯DOM的方式，可以看到，这种方式是非常麻烦的，通过纯粹的dom方式是最底层的方式，但是在现在来看，这种方式确实过于繁琐 2、数组Join法（确实没听说过也没用过） 数组join法据说是为了解决无法换行字符串（es6之前没有模板字符串）而被人们想出来的一种另类的方法，说白了实际上就是为了让代码看上去更加有结构，据说是曾经前端必回知识，下面我们看看代码： for (const item of dataItems) { const str = [ '&lt;li&gt;', ' &lt;div class=&quot;hd&quot;&gt;' + item.name + '的基本信息&lt;/div&gt;', ' &lt;div class=&quot;bd&quot;&gt;', ' &lt;p&gt;姓名：' + item.name + '&lt;/p&gt;', ' &lt;p&gt;年龄：' + item.age + '&lt;/p&gt;', ' &lt;p&gt;性别：' + item.sex + '&lt;/p&gt;', ' &lt;/div&gt;', '&lt;/li&gt;', ].join('') uEl.innerHTML += str; } 3、es6模板字符串方式 来到es6之后字符串就变得简单了，也就是模板字符串（反引号方法）可以换行来写,就算是现在，在很多场合也是很有用的，并且很多时候用起来非常的方便。 const uEl = document.getElementById(&quot;list&quot;); for (const item of dataItems) { let str = ` &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;${item.name}的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：${item.name}&lt;/p&gt; &lt;p&gt;年龄：${item.age}&lt;/p&gt; &lt;p&gt;性别：${item.sex}&lt;/p&gt; &lt;/div&gt; &lt;/li&gt;` uEl.innerHTML += str; } 4、模板引擎的方式 模板引擎，我们依据课程，采用的是mustache模板引擎的方式来实现同样的效果,mustache是最早的html模板引擎，它的出现是极具创造性的，vue等库的底层实现也是依赖模板引擎的，当然Vue有着自己的一套！ mustache开源地址：[https://github.com/janl/mustache.js/] &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.min.js&quot;&gt;&lt;/script&gt; &lt;script id=&quot;template&quot; type=&quot;x-tmpl-mustache&quot;&gt; {{#arr}} &lt;li&gt; &lt;div class=&quot;hd&quot;&gt;{{ name }}的基本信息&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p&gt;姓名：{{ name }}&lt;/p&gt; &lt;p&gt;年龄：{{ age }}&lt;/p&gt; &lt;p&gt;性别：{{ sex }}&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; {{/arr}} &lt;/script&gt; &lt;script&gt; var template = document.getElementById('template').innerHTML; var rendered = Mustache.render(template, { arr: dataItems }); document.getElementById('list').innerHTML = rendered; &lt;/script&gt; 从代码可以看出，虽然代码量不是最少的，但是其思想确实最具创造性的，通过模板的方式，结构更加清晰，让数据更加容易的生成视图。这里只是展示一个小小的例子，mustache还可以实现更加复杂的需求，比如数组的嵌套，条件判断等等 ","link":"https://cyj20142932.github.io/post/vue-yuan-ma-tan-xi-shu-ju-ru-he-bian-shi-tu/"},{"title":"CSS实用片段","content":"CSS常用的代码片段 这是CSS浏览器重置的基本和常见的CSS代码段 html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } html { height: 101%; } body { font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; } article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } strong { font-weight: bold; } table { border-collapse: collapse; border-spacing: 0; } img { border: 0; max-width: 100%; } p { font-size: 1.2em; line-height: 1.0em; color: #333; } 跨浏览器透明度设置 .transparent { -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=50)&quot;;/* IE 8 */ filter: alpha(opacity=50); /* IE 5-7 */ -moz-opacity: 0.5;/* Netscape */ -khtml-opacity: 0.5; /* Safari 1.x */ opacity: 0.5; /* Good browsers */ } 常规媒体查询 /* Smartphones (portrait and landscape) ----------- */ @media only screen and (min-device-width : 320px) and (max-device-width : 480px) { } /* Smartphones (landscape) ----------- */ @media only screen and (min-width : 321px) { } /* Smartphones (portrait) ----------- */ @media only screen and (max-width : 320px) { } /* iPads (portrait and landscape) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) { } /* iPads (landscape) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) { } /* iPads (portrait) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) { } /* Desktops and laptops ----------- */ @media only screen and (min-width : 1224px) { } /* Large screens ----------- */ @media only screen and (min-width : 1824px) { } /* iPhone 4 ----------- */ @media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) { } 自定义选中文本 ::selection { background: #51a351; } ::-moz-selection { background: #51a351; } ::-webkit-selection { background: #51a351; } 带CSS3的全屏背景 html { background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover; } 强制垂直滚动条 html { height: 101% } 文本首字母大写 p:first-letter { display: block; margin: 4px 0 0 4px; float: left; color: #ff3366; font-size: 5.3em; font-family: Georgia, Times New Roman, serif; } 内外阴影 #mydiv { -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000; } #mydiv { -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); } 语音气泡 .speech-bubble { position: relative; background: #00aabb; border-radius: .4em; } .speech-bubble:after { content: ''; position: absolute; bottom: 0; left: 50%; width: 0; height: 0; border: 30px solid transparent; border-top-color: #00aabb; border-bottom: 0; border-left: 0; margin-left: -15px; margin-bottom: -30px; } 自定义输入样式 input[type=text], textarea { -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd; } input[type=text]:focus, textarea:focus { box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1); } ","link":"https://cyj20142932.github.io/post/css-shi-yong-pian-duan/"},{"title":"Gridea博客客户端","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://cyj20142932.github.io/post/hello-gridea/"}]}